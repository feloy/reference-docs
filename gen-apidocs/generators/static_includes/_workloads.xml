<part id="strong-workloads-apis-strong">
 <title>Workloads</title>
 <partintro>
  <para>Workloads resources are responsible for managing and running your
      containers on the cluster. <link linkend="container-v1-core">Containers</link>
      are created by Controllers through <link linkend="pod-v1-core">Pods</link>.
      Pods run Containers and provide environmental dependencies such as shared or
      persistent storage <link linkend="volume-v1-core">Volumes</link> and
      <link linkend="configmap-v1-core">Configuration</link> or
      <link linkend="secret-v1-core">Secret</link> data injected into the container.</para>

  <para>The most common Controllers are:
   <itemizedlist>
    <listitem><para><link linkend="deployment-v1-apps">Deployments</link> for stateless persistent apps (e.g. HTTP servers).</para></listitem>
    <listitem><para><link linkend="statefulset-v1-apps">StatefulSets</link> for stateful persistent apps (e.g. databases).</para></listitem>
    <listitem><para><link linkend="job-v1-batch">Jobs</link> for run-to-completion apps (e.g. batch Jobs).</para></listitem>
   </itemizedlist>
  </para>

  <para>In Kubernetes, all controllers respect the principle of the <firstterm>Reconcile Loop</firstterm>:
      the controller perpetually watches for some objects of interest, to be able
      to detect if the actual state of the world (the objects running in the cluster)
      satisfies the specs of the different objects the controller is responsible
      for and to adapt the world consequently.
  </para>

  <para>From the <command>kubectl</command> command line, you can run a pod
    containing a container as simply as running this command:
    <screen>$ kubectl run --generator=run-pod/v1 nginx --image=nginx</screen>
  </para>

  <para>By adding <parameter>--dry-run -o yaml</parameter> to the command,
    you can see the YAML template you would have to write to create the same Pod:
    <screen>$ kubectl run --generator=run-pod/v1 nginx --image=nginx --dry-run -o yaml
apiVersion: v1
kind: Pod
metadata:
    creationTimestamp: null
    labels:
    run: nginx
    name: nginx
spec:
    containers:
    - image: nginx
    name: nginx
    resources: {}
    dnsPolicy: ClusterFirst
    restartPolicy: Always
status: {}
    </screen>
  </para>

  <para>Or, if you extremely simplify the template:
    <screen>-- simple.yaml
apiVersion: v1
kind: Pod
metadata:
    name: nginx
spec:
    containers:
    - name: nginx
    image: nginx
    </screen>
  </para>

  <para>You can now start the Pod by using this template:
    <screen>$ kubectl apply -f simple.yaml</screen>
  </para>

  <para>If you are a Go developer, you can use the
      <systemitem>client-go</systemitem> library to run the Pod
      (complete example at https://github.com/kubernetes/client-go/tree/master/examples/in-cluster-client-configuration):
    <screen>pod := corev1.Pod{
    ObjectMeta: metav1.ObjectMeta{
        Name: "nginx",
    },
    Spec: corev1.PodSpec{
        Containers: []corev1.Container{
            {
                Name:  "nginx",
                Image: "nginx",
            },
        },
    },
}

podsClient := clientset.CoreV1().Pods("default")
_, err := podsClient.Create(&amp;pod)
    </screen>
  </para>
</partintro>
